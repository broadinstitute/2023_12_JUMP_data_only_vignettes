[
  {
    "objectID": "howto/3_calculate_activity.html",
    "href": "howto/3_calculate_activity.html",
    "title": "Calculate phenotypic activity",
    "section": "",
    "text": "A common first analysis for morphological datasets is the activity of the cells’ phenotypes. We will use the copairs package, which makes use of mean average precision to obtain a metric of replicability for any set of morphological profiles. In other words, it indicates how similar a given set of compounds are, relative to their negative controls, which is usually cells that have experienced no perturbation.\n\n\nCode\nimport polars as pl\nimport polars.selectors as cs\nimport seaborn as sns\nfrom broad_babel.query import get_mapper\nfrom copairs.map import average_precision\n\n\nWe will be using the CRISPR dataset specificed in our index csv, but we will select a subset of perturbations and the controls present.\n\n\nCode\nINDEX_FILE = \"https://raw.githubusercontent.com/jump-cellpainting/datasets/50cd2ab93749ccbdb0919d3adf9277c14b6343dd/manifests/profile_index.csv\"\nCRISPR_URL = pl.read_csv(INDEX_FILE).filter(pl.col(\"subset\") == \"crispr\").item(0, \"url\")\nprofiles = pl.scan_parquet(CRISPR_URL)\n\n\nSample perturbations and add known negative control.\n\n\nCode\njcp_ids = (\n    profiles.select(pl.col(\"Metadata_JCP2022\")).unique().collect().to_series().sort()\n)\nsubsample = jcp_ids.sample(10, seed=42)\nsubsample = (*subsample, \"JCP2022_800002\")  # Add the only control in CRISPR data\nprofiles_subset = profiles.filter(pl.col(\"Metadata_JCP2022\").is_in(subsample)).collect()\nunique_plates = profiles_subset.filter(pl.col(\"Metadata_JCP2022\") != subsample[-1])[\n    \"Metadata_Plate\"\n].unique()\nperts_controls = profiles_subset.filter(pl.col(\"Metadata_Plate\").is_in(unique_plates))\nwith pl.Config() as cfg:\n    cfg.set_tbl_cols(7)  # Limit the number of columns printed\n    perts_controls.head()\n\n\nNow we create a mapper to label treatments and controls. See the previous tutorial for details on fetching metadata.\n\n\nCode\npert_mapper = get_mapper(\n    subsample, input_column=\"JCP2022\", output_columns=\"JCP2022,pert_type\"\n)\nperts_controls_annotated = perts_controls.with_columns(\n    pl.col(\"Metadata_JCP2022\").replace(pert_mapper).alias(\"pert_type\")\n)\n\n\nFinally we use the parameters from . See the copairs wiki for more details on the parameters that copairs requires.\n\n\nCode\npos_sameby = [\"Metadata_JCP2022\"]  # We want to match perturbations\npos_diffby = []\nneg_sameby = []\nneg_diffby = [\"pert_type\"]\nbatch_size = 20000\n\nmetadata_selector = cs.starts_with((\"Metadata\", \"pert_type\"))\nmeta = perts_controls_annotated.select(metadata_selector)\nfeatures = perts_controls_annotated.select(~metadata_selector)\n\nresult = average_precision(\n    meta.to_pandas(),\n    features.to_numpy(),\n    pos_sameby,\n    pos_diffby,\n    neg_sameby,\n    neg_diffby,\n    batch_size,\n)\nresult = pl.DataFrame(\n    result\n)  # We convert back to polars because we prefer how it prints dataframes\nresult.head()\n\n\n\n\n\n\n\n\n\n\nshape: (5, 8)\n\n\n\nMetadata_Source\nMetadata_Plate\nMetadata_Well\nMetadata_JCP2022\npert_type\nn_pos_pairs\nn_total_pairs\naverage_precision\n\n\nstr\nstr\nstr\nstr\nstr\ni64\ni64\nf64\n\n\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"I23\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.920554\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"J02\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.920515\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"L23\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.931227\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"O23\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.92076\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"M02\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.951237\n\n\n\n\n\n\n\nThe result of copairs is a dataframe containing, in addition to the original metadata, the average precision with which perturbations were retrieved. Perturbations that look more similar to each other than to the negative controls in the plates present in the same plates will be higher. Perturbations that do not differentiate themselves against negative controls will be closer to zero.\nTo wrap up we pull the standard gene symbol and plot the distribution of average precision.\n\n\nCode\nname_mapper = get_mapper(\n    subsample, input_column=\"JCP2022\", output_columns=\"JCP2022,standard_key\"\n)\n\nto_plot = result.filter(pl.col(\"pert_type\") == \"trt\").with_columns(\n    pl.col(\"Metadata_JCP2022\").replace(name_mapper).alias(\"Perturbed gene\")\n)\n\n# Plotting\nsns.stripplot(data=to_plot.to_pandas(), x=\"average_precision\", y=\"Perturbed gene\")\n\n\n\n\n\n\n\n\n\nWe can see that only some perturbations can be easily retrieved when compared to negative controls, in this case KIF16B and CDK20. For a deeper dive into how mean Average Precision (mAP) works, you can explore this notebook.",
    "crumbs": [
      "How-To Guides",
      "Calculate phenotypic activity"
    ]
  },
  {
    "objectID": "howto/2_add_metadata.html",
    "href": "howto/2_add_metadata.html",
    "title": "Incorporate metadata into profiles",
    "section": "",
    "text": "A very common task when processing morphological profiles is knowing which ones are treatments and which ones are controls. Here we will explore how we can use broad-babel to accomplish this task.\n\n\nCode\nimport polars as pl\nfrom broad_babel.query import get_mapper\n\n\nWe will be using the CRISPR dataset specificed in our index csv.\n\n\nCode\nINDEX_FILE = \"https://raw.githubusercontent.com/jump-cellpainting/datasets/50cd2ab93749ccbdb0919d3adf9277c14b6343dd/manifests/profile_index.csv\"\nCRISPR_URL = pl.read_csv(INDEX_FILE).filter(pl.col(\"subset\") == \"crispr\").item(0, \"url\")\nprofiles = pl.scan_parquet(CRISPR_URL)\nprint(profiles.collect_schema().names()[:6])\n\n\n['Metadata_Source', 'Metadata_Plate', 'Metadata_Well', 'Metadata_JCP2022', 'X_1', 'X_2']\n\n\nFor simplicity the contents of our processed profiles are minimal: “The profile origin” (source, plate and well) and the unique JUMP identifier for that perturbation. We will use broad-babel to further expand on this metadata, but for simplicity’s sake let us sample subset of data.\n\n\nCode\njcp_ids = (\n    profiles.select(pl.col(\"Metadata_JCP2022\")).unique().collect().to_series().sort()\n)\nsubsample = jcp_ids.sample(10, seed=42)\n# Add a well-known control\nsubsample = (*subsample, \"JCP2022_800002\")\nsubsample\n\n\n('JCP2022_801270',\n 'JCP2022_802425',\n 'JCP2022_802356',\n 'JCP2022_805808',\n 'JCP2022_804300',\n 'JCP2022_801205',\n 'JCP2022_802539',\n 'JCP2022_803663',\n 'JCP2022_800116',\n 'JCP2022_801847',\n 'JCP2022_800002')\n\n\nWe will use these JUMP ids to obtain a mapper that indicates the perturbation type (trt, negcon or, rarely, poscon)\n\n\nCode\npert_mapper = get_mapper(\n    subsample, input_column=\"JCP2022\", output_columns=\"JCP2022,pert_type\"\n)\npert_mapper\n\n\n{'JCP2022_800116': 'trt',\n 'JCP2022_805808': 'trt',\n 'JCP2022_802425': 'trt',\n 'JCP2022_803663': 'trt',\n 'JCP2022_802539': 'trt',\n 'JCP2022_801847': 'trt',\n 'JCP2022_800002': 'negcon',\n 'JCP2022_804300': 'trt',\n 'JCP2022_802356': 'trt',\n 'JCP2022_801270': 'trt',\n 'JCP2022_801205': 'trt'}\n\n\nA couple of important notes about broad_babel’s get mapper and other functions: - these must be fed tuples, as these are cached and provide significant speed-ups for repeated calls - ‘get-mapper’ works for datasets for up to a few tens of thousands of samples. If you try to use it to get a mapper for the entirety of the ‘compounds’ dataset it is likely to fail. For these cases we suggest the more general function ‘run_query’. You can read more on this and other use-cases on Babel’s readme.\nWe will now repeat the process to get their ‘standard’ name\n\n\nCode\nname_mapper = get_mapper(\n    (*subsample, \"JCP2022_800002\"),\n    input_column=\"JCP2022\",\n    output_columns=\"JCP2022,standard_key\",\n)\nname_mapper\n\n\n{'JCP2022_803663': 'KIF16B',\n 'JCP2022_804300': 'MSX1',\n 'JCP2022_800002': 'non-targeting',\n 'JCP2022_805808': 'RAD51B',\n 'JCP2022_801847': 'DMRT2',\n 'JCP2022_802425': 'FLNC',\n 'JCP2022_802539': 'G6PC',\n 'JCP2022_801205': 'CDK20',\n 'JCP2022_800116': 'ACOT11',\n 'JCP2022_801270': 'CFB',\n 'JCP2022_802356': 'FDX1'}\n\n\nTo wrap up, we will fetch all the available profiles for these perturbations and use the mappers to add the missing metadata. We also select a few features to showcase how how selection can be performed in polars.\n\n\nCode\nsubsample_profiles = profiles.filter(\n    pl.col(\"Metadata_JCP2022\").is_in(subsample)\n).collect()\nprofiles_with_meta = subsample_profiles.with_columns(\n    pl.col(\"Metadata_JCP2022\").replace(pert_mapper).alias(\"pert_type\"),\n    pl.col(\"Metadata_JCP2022\").replace(name_mapper).alias(\"name\"),\n)\nprofiles_with_meta.select(\n    pl.col((\"name\", \"pert_type\", \"^Metadata.*$\", \"^X_[0-3]$\"))\n).sort(by=\"pert_type\")\n\n\n\n\nshape: (2_806, 9)\n\n\n\nname\npert_type\nMetadata_Source\nMetadata_Plate\nMetadata_Well\nMetadata_JCP2022\nX_1\nX_2\nX_3\n\n\nstr\nstr\nstr\nstr\nstr\nstr\nf32\nf32\nf32\n\n\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"A02\"\n\"JCP2022_800002\"\n-0.223417\n-0.049487\n-0.826231\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"L23\"\n\"JCP2022_800002\"\n-0.079349\n-0.016958\n-0.277558\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"I23\"\n\"JCP2022_800002\"\n-0.023832\n-0.00537\n-0.29832\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"J02\"\n\"JCP2022_800002\"\n-0.169491\n-0.023422\n-0.088187\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"O23\"\n\"JCP2022_800002\"\n-0.295112\n-0.124241\n1.055193\n\n\n…\n…\n…\n…\n…\n…\n…\n…\n…\n\n\n\"CFB\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R5-19\"\n\"G12\"\n\"JCP2022_801270\"\n0.023277\n0.021747\n-0.914867\n\n\n\"DMRT2\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R5-21\"\n\"C10\"\n\"JCP2022_801847\"\n-0.208865\n-0.046884\n0.845933\n\n\n\"MSX1\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R5-24\"\n\"C03\"\n\"JCP2022_804300\"\n-0.003333\n0.053181\n0.078227\n\n\n\"CFB\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R6-19\"\n\"G12\"\n\"JCP2022_801270\"\n0.18701\n0.072405\n0.381239\n\n\n\"CFB\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R7-19\"\n\"G12\"\n\"JCP2022_801270\"\n0.051818\n-0.129935\n-0.481606",
    "crumbs": [
      "How-To Guides",
      "Incorporate metadata into profiles"
    ]
  },
  {
    "objectID": "howto/4_display_perturbation_images.html",
    "href": "howto/4_display_perturbation_images.html",
    "title": "Plot all channels for one site",
    "section": "",
    "text": "This notebook demonstrates how to retrieve and plot all channels for one site using the jump_portrait library.\n\n\nCode\nimport matplotlib.colors as mpl  # noqa: CPY001\nimport numpy as np\nimport polars as pl\nfrom jump_portrait.fetch import get_item_location_info, get_jump_image\nfrom matplotlib import pyplot as plt\n\n\nDownloading data from 'https://zenodo.org/records/12211976/files/babel.db' to file '/home/runner/.cache/pooch/2eaa6a2f4915f72d7100683f53982ed8-babel.db'.\n\n\nFirst, we need to get location information telling us where all images corresponding to a specific perturbation can be found. We will use the “get_item_location” function from jump_portrait for this. Here we retrieve image locations for the “RAB30” gene:\n\n\nCode\ngene_info = get_item_location_info(\"RAB30\")\ngene_info.shape\n\n\nDownloading data from 'https://github.com/jump-cellpainting/datasets/raw/c68deb2babc83747e6b14d8a77e5655138a6086a/metadata/well.csv.gz' to file '/home/runner/.cache/pooch/4efbf4dd3dd9aaecc8ccb9fc3c6b4122-well.csv.gz'.\nDownloading data from 'https://github.com/jump-cellpainting/datasets/raw/c68deb2babc83747e6b14d8a77e5655138a6086a/metadata/plate.csv.gz' to file '/home/runner/.cache/pooch/a530bb82de29e39332bdef6f29397769-plate.csv.gz'.\n\n\n(90, 28)\n\n\nThere are 90 images: 9 sites/well X 5 replicate wells X 2 data types (CRISPR & ORF). We can also retrieve locations for compound data. By default, the function assumes a query by INCHI key. We can also query by JCP ID by specifying the query column:\n\n\nCode\ncmpd_info_byinchi = get_item_location_info(\"CLETVKMYAXARPO-UHFFFAOYSA-N\")\ncmpd_info_byjcp = get_item_location_info(\"JCP2022_011844\", input_column=\"JCP2022\")\n\nprint(cmpd_info_byinchi.shape)\nprint(cmpd_info_byjcp.shape)\n\n\n(34, 28)\n(34, 28)\n\n\nThere are 34 sites corresponding to this compound. We’ve written a function to display all channels for a specific image. Note that this is just one possible way to display images - we’ve included the function here so that you can modify it to suit your own needs.\n\n\nCode\ndef display_site(\n    source: str,\n    batch: str,\n    plate: str,\n    well: str,\n    site: str,\n    label: str,\n    int_percentile: float,\n) -&gt; None:\n    \"\"\"Plot all channels from one image.\n\n    Parameters\n    ----------\n    source : String\n        Source ID for image of interest.\n    batch : String\n        Batch ID for image of interest.\n    plate : String\n        Plate ID for image of interest.\n    well : String\n        Well ID for image of interest.\n    site : String\n        Site ID for image of interest.\n    label : String\n        Label to display in lower left corner.\n    int_percentile: float\n        Rescale the image from 0 - this percentile of intensity values.\n\n    \"\"\"\n    n_rows = 2\n    n_cols = 3\n\n    # Make images\n    axes = plt.subplots(n_rows, n_cols, figsize=(2.6 * n_cols, 2.6 * n_rows))[1]\n    axes = axes.ravel()\n    counter = 0\n\n    channel_rgb = {\n        \"DNA\": \"#FF0000\",  # Blue\n        \"ER\": \"#65fe08\",  # Green\n        \"Mito\": \"#FFFF00\",  # Red\n        \"AGP\": \"#FFFF00\",  # Yellow\n        \"RNA\": \"#FFA500\",  # Orange\n    }\n\n    for ax, (channel, rgb) in zip(axes, channel_rgb.items()):\n        cmap = mpl.LinearSegmentedColormap.from_list(channel, (\"#000\", rgb))\n\n        img = get_jump_image(source, batch, plate, well, channel, site, None)\n\n        ax.imshow(img, vmin=0, vmax=np.percentile(img, int_percentile), cmap=cmap)\n        ax.axis(\"off\")\n\n        # Add channel name label in the top left corner\n        ax.text(\n            0.05,\n            0.95,\n            channel,\n            horizontalalignment=\"left\",\n            verticalalignment=\"top\",\n            fontsize=18,\n            color=\"black\",\n            bbox=dict(\n                facecolor=\"white\", alpha=0.8, edgecolor=\"none\", boxstyle=\"round,pad=0.3\"\n            ),\n            transform=ax.transAxes,\n        )\n\n    # put label in last subplot\n    ax = axes[-1]\n    ax.text(\n        0.5,\n        0.5,\n        label,\n        horizontalalignment=\"center\",\n        verticalalignment=\"center\",\n        fontsize=20,\n        color=\"black\",\n        transform=ax.transAxes,\n    )\n    ax.axis(\"off\")\n\n    # show plot\n    plt.tight_layout()\n\n\nWe can get the required location parameters from the location info that we retrieved earlier. Here we get parameters for the first site in the JCP compound results:\n\n\nCode\nsource, batch, plate, well, site, *rest = cmpd_info_byjcp.row(0)\n\n\nNext, we define the label and make the plot:\n\n\nCode\nlabel = \"{}\\n\\nplate:\\n{}\\nwell: {}\\nsite: {}\"\n\ndisplay_site(\n    source,\n    batch,\n    plate,\n    well,\n    site,\n    label.format(\"JCP2022_011844\", plate, well, site),\n    99.5,\n)\n\n\n\n\n\n\n\n\n\nHere, we plot one of the RAB30 ORF images:\n\n\nCode\nsource, batch, plate, well, site, *rest = gene_info.filter(\n    pl.col(\"Metadata_PlateType\") == \"ORF\"\n).row(0)\ndisplay_site(\n    source,\n    batch,\n    plate,\n    well,\n    site,\n    label.format(\"RAB30 (ORF)\", plate, well, site),\n    99.5,\n)\n\n\n\n\n\n\n\n\n\nAnd for CRISPR:\n\n\nCode\nsource, batch, plate, well, site, *rest = gene_info.filter(\n    pl.col(\"Metadata_PlateType\") == \"CRISPR\"\n).row(0)\ndisplay_site(\n    source,\n    batch,\n    plate,\n    well,\n    site,\n    label.format(\"RAB30 (CRISPR)\", plate, well, site),\n    99.5,\n)",
    "crumbs": [
      "How-To Guides",
      "Plot all channels for one site"
    ]
  },
  {
    "objectID": "explanations/FAQ.html",
    "href": "explanations/FAQ.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Frequently Asked Questions\n\nAnalyses\n\nHow can I reproduce an environment to explore JUMP data?\n\nData\n\nDoes JUMP contain X compound/gene?\nWhere are the datasets specification?\nWhy are some images with corresponding images but no downstream analysis?\nWhy do some perturbations have so many replicates\nHow were the profiles created?\nDo we we expect one JCP to have multiple targets?\nDo JCPs within either the CRISPR or ORF share the same gene?\nWeb interfaces\nFrequently Asked Questions and links to their answers. They are grouped based on whether they pertain to data, libraries or analyses.",
    "crumbs": [
      "Explanations",
      "Frequently Asked Questions"
    ]
  },
  {
    "objectID": "explanations/FAQ.html#analyses",
    "href": "explanations/FAQ.html#analyses",
    "title": "Frequently Asked Questions",
    "section": "Analyses",
    "text": "Analyses\n\n\nHow can I reproduce an environment to explore JUMP data?\n(WIP) The easiest way to set things up will be installing from pip in your enviromnment of choice:\npip install jump-deps",
    "crumbs": [
      "Explanations",
      "Frequently Asked Questions"
    ]
  },
  {
    "objectID": "explanations/FAQ.html#data",
    "href": "explanations/FAQ.html#data",
    "title": "Frequently Asked Questions",
    "section": "Data",
    "text": "Data\n\n\nDoes JUMP contain X compound/gene?\nThe easiest way to find out is querying your dataset using this web tool. Alternatively, you can explore the metadata tables on the datasets repository.\n\n\n\nWhere are the datasets specification?\nThe main resource to understand the technicalities of the JUMP datasets collection and assembly is on this repo.\n\n\n\nWhy are some images with corresponding images but no downstream analysis?\nSome plates failed Quality Control (QC) but we kept them because they may be useful for developing QC methods.\n\n\n\nWhy do some perturbations have so many replicates\nMost plates contain 16 negative control wells, while some have as many as 28 wells. One replicate of four of the compound positive controls are added to wells O23, O24, P23 and P24. The remaining wells contain ORF treatments, with a single replicate of each per plate map and with five replicate plates produced per plate map (issue).\n\n\n\nHow were the profiles created?\nWe used snakemake and pycytominer to generate these. The details can be found in this repo.\n\n\n\nDo we we expect one JCP to have multiple targets?\nYes, there will be many with multiple targets. For instance, JCP2022_050797 (quinidine/quinine) has the targets KCNK1 and KCNN4.\nTwo were considered to be two different compounds because they had different names and broad_sample names. But after all the data cleanup steps, they ended up being the same. Hence two different entries.\n\n\n\nDo JCPs within either the CRISPR or ORF share the same gene?\nIn CRISPR each JCP ID corresponds to a different gene. But in ORF there are sometimes multiple reagents targeting the same gene. In this case, we compute consensus profiles at the gene level (more info here).\n\n\n\nWeb interfaces\n\nWhat is the source of the replicability metric?\nThese two files (ORF and CRISPR) contain the mAP and corrected p values for replicate retrieval. They won’t contain all ORF and CRISPR reagents because so of them were filtered out for qc reasons.\nX_Feature: For each row, is the Feature value an average for all the cells in the Metadata_image using the listed Mask? Or is it associated with a single cell in that image?\nAny Feature is the average of all cells and all replicates (typically four in total) for the specific mask and feature.\nHow are Statistic and Median calculated for each row? Are they calculated in relation to the average of the “Feature” values for the negative controls in the same plate?\n\nStatistic is the probability of a given distribution (four replicates) to occur relative to their negative controls (in the four plates, typically each replicate is in an independent plate).\nMedian is the median feature across all (~4) replicates. Each of these replicates’ value was in turn the mean of all the sites and cells in a given well.",
    "crumbs": [
      "Explanations",
      "Frequently Asked Questions"
    ]
  },
  {
    "objectID": "explanations/Resources.html",
    "href": "explanations/Resources.html",
    "title": "Available resources",
    "section": "",
    "text": "Available resources\n\n\n\nAvailable resources\n\nHome website: Access news and related publications.\nWe provide Open Source Web “JUMPer” interfaces for all three datasets (CRISPR, ORF and Compound). For more details follow this link.\nArdigen provides a website to explore a representation (requires creating a free account).\nSpring Science also provides a website for data exploration (account needed).",
    "crumbs": [
      "Explanations",
      "Available resources"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "This is work in progress. The purpose of this resource is to concentrate all the useful and up-to-date information necessary to make use of JUMP. It aims to summarise the most useful information, including examples, guides, know-hows and links to more material for deeper dives into data acquisition, processing, sharing and visualisation.\n\n\nHere you can find the up-to-date web tools to explore JUMP from your browser.\n\n\n\nOur monorepo hosts Python libraries that may help you access JUMP data in a high-throughput manner.\n\n\n\nThis table provides direct link to run the guides on your browser. Google Colab is the only supported web interface.\n\n\n\nGoogle Collab\n\n\n\n\nRetrieve JUMP profiles\n\n\nAdd metadata to profiles\n\n\nCalculate phenotypic activity\n\n\nDisplay perturbation images\n\n\nExplore perturbation clusters\n\n\nQuery genes for more info\n\n\n\nAlternatively, you can download the notebooks from their respective pages and run them in your local Python environment. We have published a package containing all dependencies, you need only install in your environment using pip install jump_deps (Python 3.10 or 3.11).\n\n\n\nTo provide up-to-date info on everything JUMP-related. We aim to minimize friction for developers, technical writers and biologists to produce and access novel insights and tools. We believe complexity is one of the biggest challenges in challenge, hampering collaboration and novel biological insights. We aim to make this the one-stop shop for the vast majority of JUMP questions, be it computational or biological.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#i-just-want-to-access-the-web-tools",
    "href": "index.html#i-just-want-to-access-the-web-tools",
    "title": "Overview",
    "section": "",
    "text": "Here you can find the up-to-date web tools to explore JUMP from your browser.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#i-am-a-developer-interested-in-using-and-writing-programatic-tools-for-jump",
    "href": "index.html#i-am-a-developer-interested-in-using-and-writing-programatic-tools-for-jump",
    "title": "Overview",
    "section": "",
    "text": "Our monorepo hosts Python libraries that may help you access JUMP data in a high-throughput manner.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#how-can-i-access-the-how-to-guides-in-a-live-coding-environment",
    "href": "index.html#how-can-i-access-the-how-to-guides-in-a-live-coding-environment",
    "title": "Overview",
    "section": "",
    "text": "This table provides direct link to run the guides on your browser. Google Colab is the only supported web interface.\n\n\n\nGoogle Collab\n\n\n\n\nRetrieve JUMP profiles\n\n\nAdd metadata to profiles\n\n\nCalculate phenotypic activity\n\n\nDisplay perturbation images\n\n\nExplore perturbation clusters\n\n\nQuery genes for more info\n\n\n\nAlternatively, you can download the notebooks from their respective pages and run them in your local Python environment. We have published a package containing all dependencies, you need only install in your environment using pip install jump_deps (Python 3.10 or 3.11).",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#what-is-the-purpose-of-this-website",
    "href": "index.html#what-is-the-purpose-of-this-website",
    "title": "Overview",
    "section": "",
    "text": "To provide up-to-date info on everything JUMP-related. We aim to minimize friction for developers, technical writers and biologists to produce and access novel insights and tools. We believe complexity is one of the biggest challenges in challenge, hampering collaboration and novel biological insights. We aim to make this the one-stop shop for the vast majority of JUMP questions, be it computational or biological.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "Additional uses",
    "section": "",
    "text": "Additional uses\n\nFocal point for JUMP information and data analysis pipelines.\n\n\nAdditional uses\nThis repository can be used as a way to install essential dependencies for an exploratory analysis of JUMP morphological data."
  },
  {
    "objectID": "explanations/glossary.html",
    "href": "explanations/glossary.html",
    "title": "Glossary and Acronyms",
    "section": "",
    "text": "Glossary and Acronyms\n\nAcronyms\n\nOther definitions\nReference for terms and their definition.",
    "crumbs": [
      "Explanations",
      "Glossary and Acronyms"
    ]
  },
  {
    "objectID": "explanations/glossary.html#acronyms",
    "href": "explanations/glossary.html#acronyms",
    "title": "Glossary and Acronyms",
    "section": "Acronyms",
    "text": "Acronyms\n\nJUMP: Joint Undertaking for Morphological Profiling\nmAP: mean Average Precision\nCRISPR: Clustered Regularly Interspaced Short Palindromic Repeats. This method was used to produce the CRISPR datasets, whence genes were knocked-out.\nORF: Open Reading Frame. The ORF dataframe is comprised of overexpressed genes.",
    "crumbs": [
      "Explanations",
      "Glossary and Acronyms"
    ]
  },
  {
    "objectID": "howto/5_explore_distance_clusters.html",
    "href": "howto/5_explore_distance_clusters.html",
    "title": "Explore perturbation clusters",
    "section": "",
    "text": "A common question we aim to ask is “What other perturbations look like mine?” The easiest way to get the answer for this question is using our browsable datasets. In this case we would like to use the ‘Matches’ databases, which provide cosines similarities between perturbations within a dataset, obtained from all-vs-all calculations.\nThe limitation of this approach is that the size of JUMP results in two challenges: - Calculating the distances across all pairs of perturbations is intractable for most computers without a GPU (Graphics Processing Unit). - The resultant similarity matrix is too big for web browser-based exploration, so we limit the browsable similarity dataset to tthe op 100 most correlated/anticorrelated pairs of perturbations.\nDespite the aforementioned problems, we provide the full matrix of perturbation distances in case it is of use to data analysts. You can find this and other datasets on Zenodo. The data files of interest for this exercise are “{org,crispr}_cosinesim_full.parquet”.\nThe following analysis focuses on showcasing how to query one of these distance matrices to find all the distances between any given perturbation and all others. One use-case of this is testing how similar perturbation A and B are relative to perturbation C’s similarity to A.\n\n\n\nCode\nfrom random import choices, seed\n\nimport matplotlib.pyplot as plt\nimport polars as pl\nimport seaborn as sns\n\n\nWe select the CRISPR dataset for this example. As with previous examples, this is a lazy-loaded data frame. This enables us to download very big datasets without worrying about whether or not they will fill into memory. In these datasets, the values range between 0 and 2, where 0 means that two profiles are the same, 1 means that they are orthogonal (completely uncorrelated) and 2 means that they are completely anticorrelated.\n\n\nCode\ndistances = pl.scan_parquet(\n    \"https://zenodo.org/api/records/13259495/files/crispr_cosinesim_full.parquet/content\"\n)\ndistances.head().collect()\n\n\n\n\nshape: (5, 7_977)\n\n\n\nJCP2022_805250\nJCP2022_804898\nJCP2022_805900\nJCP2022_807210\nJCP2022_803410\nJCP2022_807794\nJCP2022_800876\nJCP2022_800830\nJCP2022_805681\nJCP2022_802504\nJCP2022_800777\nJCP2022_800497\nJCP2022_804796\nJCP2022_806564\nJCP2022_801225\nJCP2022_807865\nJCP2022_803439\nJCP2022_807178\nJCP2022_802128\nJCP2022_801787\nJCP2022_807440\nJCP2022_804038\nJCP2022_801171\nJCP2022_802228\nJCP2022_801332\nJCP2022_804693\nJCP2022_800784\nJCP2022_803011\nJCP2022_801962\nJCP2022_805986\nJCP2022_807402\nJCP2022_800462\nJCP2022_801558\nJCP2022_807179\nJCP2022_806226\nJCP2022_806465\nJCP2022_801814\n…\nJCP2022_805180\nJCP2022_807889\nJCP2022_804285\nJCP2022_805626\nJCP2022_805864\nJCP2022_803826\nJCP2022_800780\nJCP2022_804308\nJCP2022_804821\nJCP2022_803189\nJCP2022_804291\nJCP2022_805854\nJCP2022_807379\nJCP2022_805728\nJCP2022_807071\nJCP2022_800371\nJCP2022_806829\nJCP2022_806376\nJCP2022_802049\nJCP2022_805085\nJCP2022_806543\nJCP2022_806740\nJCP2022_805128\nJCP2022_800014\nJCP2022_801188\nJCP2022_800488\nJCP2022_804935\nJCP2022_802784\nJCP2022_800258\nJCP2022_803251\nJCP2022_801353\nJCP2022_807322\nJCP2022_802236\nJCP2022_806494\nJCP2022_805767\nJCP2022_805144\nJCP2022_802646\n\n\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\n…\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\n\n\n\n\n5.9605e-7\n1.247144\n0.967903\n1.132685\n1.052072\n1.073054\n1.070843\n1.051375\n1.129689\n0.772845\n1.0463\n1.092238\n0.906448\n0.927316\n0.896206\n1.036608\n1.109385\n0.904212\n0.942388\n1.075579\n0.991834\n0.915789\n1.074332\n1.086189\n1.089866\n1.011456\n1.151555\n1.030307\n1.027324\n0.933274\n1.164992\n1.059377\n0.927121\n0.859473\n1.055\n0.908565\n0.91787\n…\n0.899526\n1.067557\n1.222073\n1.13687\n0.84244\n1.301761\n1.030211\n0.8842\n0.903793\n0.941208\n0.96786\n0.92024\n0.988243\n1.038809\n1.023377\n0.866169\n0.982345\n0.862695\n0.950073\n1.013993\n0.963446\n0.964861\n1.221614\n1.012841\n1.116919\n1.044985\n0.95041\n0.873647\n1.092933\n0.9966\n1.11305\n0.92142\n0.898604\n1.068462\n0.939565\n0.981605\n0.837548\n\n\n1.247144\n5.3644e-7\n0.849671\n0.742207\n0.902\n0.880709\n1.000254\n0.834797\n0.89356\n1.076251\n1.022806\n1.029713\n1.053186\n1.053384\n1.129679\n1.155893\n0.817272\n0.989782\n1.048217\n0.978221\n1.135644\n0.74395\n0.988017\n0.974628\n0.926641\n0.893171\n0.802536\n1.050146\n1.08058\n0.915889\n0.746005\n1.091021\n1.142545\n1.149375\n0.891322\n0.981572\n0.981943\n…\n1.016775\n0.947588\n0.84507\n0.9275\n1.23627\n0.876745\n1.046394\n1.011125\n1.086978\n1.042936\n1.199081\n1.228067\n1.03397\n0.855395\n0.930174\n1.223315\n0.99053\n1.105305\n1.011096\n1.020536\n1.084031\n1.091003\n0.90998\n0.842879\n0.86072\n0.904132\n1.179529\n1.222647\n1.050518\n1.048739\n0.795272\n1.157747\n0.963267\n0.858091\n0.834493\n1.040158\n0.957812\n\n\n0.967903\n0.849671\n4.1723e-7\n0.907077\n1.031568\n0.982156\n1.005138\n1.092488\n1.073875\n0.870309\n1.030525\n1.066498\n1.007132\n0.851524\n1.058993\n1.102674\n0.921328\n0.976307\n1.042816\n1.11988\n1.009265\n0.828333\n0.960826\n0.980577\n0.931674\n0.935145\n0.977908\n0.846657\n0.916294\n0.986605\n0.968405\n0.920526\n1.145505\n0.947867\n0.895159\n1.022881\n0.865911\n…\n0.914141\n0.919133\n1.013684\n1.079146\n0.834806\n0.939826\n1.008615\n0.962056\n0.976553\n1.100624\n0.997636\n1.123526\n1.093243\n0.950548\n1.028595\n1.082327\n0.841474\n1.073792\n1.06748\n0.992501\n1.084669\n0.850902\n0.964968\n1.112577\n1.068541\n0.824711\n1.10152\n0.929986\n1.058774\n1.133116\n1.010063\n0.967616\n0.895663\n0.990082\n1.114065\n0.897693\n1.017657\n\n\n1.132685\n0.742207\n0.907077\n6.5565e-7\n1.205265\n0.890984\n1.142175\n0.86796\n1.042397\n0.958762\n0.944834\n1.103978\n0.884924\n1.070043\n0.973253\n1.231588\n0.567953\n0.995585\n1.046111\n1.208642\n0.821681\n0.803467\n0.899464\n0.802612\n1.083011\n0.953896\n0.888156\n0.90227\n0.966256\n0.826272\n0.830262\n1.104464\n1.044595\n0.926648\n0.956805\n0.949712\n1.097377\n…\n0.97032\n0.843955\n0.68654\n1.000185\n1.004951\n0.868828\n0.721056\n1.027855\n0.954742\n0.914465\n1.154364\n1.339245\n0.956219\n0.800423\n1.099996\n1.189476\n0.917771\n1.076726\n1.169464\n1.080106\n1.296887\n0.859278\n0.977511\n0.758992\n0.841586\n0.943176\n1.098098\n1.207128\n1.105987\n1.14492\n1.192619\n1.358119\n0.780779\n0.934115\n0.818462\n0.685961\n0.871601\n\n\n1.052072\n0.902\n1.031568\n1.205265\n4.1723e-7\n1.034174\n0.850223\n1.247003\n0.878785\n1.073189\n1.005777\n0.913054\n1.013503\n1.011858\n1.135321\n0.810449\n1.250481\n0.960766\n0.864973\n0.733279\n1.248159\n1.069302\n0.992714\n1.240854\n0.922457\n0.789956\n1.011713\n0.99239\n1.180302\n1.230094\n0.914126\n0.922827\n0.941237\n0.978482\n0.957761\n0.867414\n1.03808\n…\n0.944449\n1.159692\n1.051106\n1.082658\n1.102017\n1.116237\n1.092143\n1.060347\n1.016548\n1.207051\n1.047528\n0.725492\n0.964185\n1.007569\n0.965586\n1.00403\n0.848321\n1.084304\n0.876304\n0.958506\n0.938069\n1.066701\n1.001688\n1.072793\n1.077091\n0.904107\n1.080146\n0.93987\n0.70647\n1.067201\n0.926861\n0.839981\n1.144658\n1.186504\n1.104135\n1.42188\n1.148127\n\n\n\n\n\n\n\nNote that the only metadata information in this matrix are the column names as JUMP IDs (JCP2022_X), meaning that we will need to use a mapper from these JUMP ids to conventional names; feel free to look at the previous how-to that demonstrates that. We will now select three features at random and look at their correlation matrix\n\n\nCode\nseed(42)\ncols = distances.collect_schema().names()\nncols = len(cols)\nsampled_col_idx = sorted(choices(range(ncols), k=3))\nsampled_cols = [cols[ix] for ix in sampled_col_idx]\n\nsampled_distances = (\n    distances.with_row_index()\n    .filter(pl.col(\"index\").is_in(sampled_col_idx))\n    .select(pl.col(sampled_cols))\n    .collect()\n)\nsampled_distances\n\n\n\n\nshape: (3, 3)\n\n\n\nJCP2022_801809\nJCP2022_805029\nJCP2022_801476\n\n\nf32\nf32\nf32\n\n\n\n\n4.7684e-7\n0.945577\n1.091766\n\n\n0.945577\n5.9605e-7\n0.961309\n\n\n1.091766\n0.961309\n3.5763e-7\n\n\n\n\n\n\n\nFinally, we plot them in a heatmap for easier visualisation\n\n\nCode\npandas_correlation = sampled_distances.to_pandas()\npandas_correlation.index = pandas_correlation.columns\nsns.heatmap(\n    pandas_correlation,\n    annot=True,\n    fmt=\".3f\",\n    vmin=0,\n    vmax=2,\n    cmap=sns.color_palette(\"vlag\", as_cmap=True),\n)\nplt.yticks(rotation=30)\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\nWhilst in this case it is not a terribly interesting result, this shows that we see no correlation between three randomly selected perturbations.",
    "crumbs": [
      "How-To Guides",
      "Explore perturbation clusters"
    ]
  },
  {
    "objectID": "howto/1_retrieve_profiles.html",
    "href": "howto/1_retrieve_profiles.html",
    "title": "Retrieve JUMP profiles",
    "section": "",
    "text": "This is a tutorial on how to access profiles from the JUMP Cell Painting datasets. We will use polars to fetch the data frames lazily, with the help of s3fs and pyarrow. We prefer lazy loading because the data can be too big to be handled in memory.\n\n\nCode\nimport polars as pl\n\n\nThe shapes of the available datasets are:\n\ncpg0016-jump[crispr]: CRISPR knockouts genetic perturbations.\ncpg0016-jump[orf]: Overexpression genetic perturbations.\ncpg0016-jump[compound]: Chemical perturbations.\n\nTheir explicit location is determined by the transformations that produce the datasets. The aws paths of the dataframes are built from a prefix below:\n\n\nCode\nINDEX_FILE = \"https://raw.githubusercontent.com/jump-cellpainting/datasets/50cd2ab93749ccbdb0919d3adf9277c14b6343dd/manifests/profile_index.csv\"\n\n\nWe use a version-controlled csv to release the latest corrected profiles\n\n\nCode\nprofile_index = pl.read_csv(INDEX_FILE)\nprofile_index.head()\n\n\n\n\nshape: (5, 3)\n\n\n\nsubset\nurl\netag\n\n\nstr\nstr\nstr\n\n\n\n\n\"orf\"\n\"https://cellpainting-gallery.s…\n\"c05a241135dcedda4e9cc639480b3f…\n\n\n\"crispr\"\n\"https://cellpainting-gallery.s…\n\"4c59782c0dd5244f67d14323e83258…\n\n\n\"compound\"\n\"https://cellpainting-gallery.s…\n\"1368a48ddbd4c44b1bfbc084591aaf…\n\n\n\"orf_interpretable\"\n\"https://cellpainting-gallery.s…\n\"97b0c31d7d678ca2a5e2353df5799f…\n\n\n\"crispr_interpretable\"\n\"https://cellpainting-gallery.s…\n\"90b08b824c06bcf16dfc5e788e74f0…\n\n\n\n\n\n\n\nWe do not need the ‘etag’ (used to check file integrity) column nor the ‘interpretable’ (i.e., before major modifications)\n\n\nCode\nselected_profiles = profile_index.filter(\n    pl.col(\"subset\").is_in((\"crispr\", \"orf\", \"compound\"))\n).select(pl.exclude(\"etag\"))\nfilepaths = dict(selected_profiles.iter_rows())\nprint(filepaths)\n\n\n{'orf': 'https://cellpainting-gallery.s3.amazonaws.com/cpg0016-jump-assembled/source_all/workspace/profiles/jump-profiling-recipe_2024_a917fa7/ORF/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony.parquet', 'crispr': 'https://cellpainting-gallery.s3.amazonaws.com/cpg0016-jump-assembled/source_all/workspace/profiles/jump-profiling-recipe_2024_a917fa7/CRISPR/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony_PCA_corrected/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony_PCA_corrected.parquet', 'compound': 'https://cellpainting-gallery.s3.amazonaws.com/cpg0016-jump-assembled/source_all/workspace/profiles/jump-profiling-recipe_2024_a917fa7/COMPOUND/profiles_var_mad_int_featselect_harmony/profiles_var_mad_int_featselect_harmony.parquet'}\n\n\nWe will lazy-load the dataframes and print the number of rows and columns\n\n\nCode\ninfo = {k: [] for k in (\"dataset\", \"#rows\", \"#cols\", \"#Metadata cols\", \"Size (MB)\")}\nfor name, path in filepaths.items():\n    data = pl.scan_parquet(path)\n    n_rows = data.select(pl.len()).collect().item()\n    schema = data.collect_schema()\n    metadata_cols = [col for col in schema.keys() if col.startswith(\"Metadata\")]\n    n_cols = schema.len()\n    n_meta_cols = len(metadata_cols)\n    estimated_size = int(round(4.03 * n_rows * n_cols / 1e6, 0))  # B -&gt; MB\n    for k, v in zip(info.keys(), (name, n_rows, n_cols, n_meta_cols, estimated_size)):\n        info[k].append(v)\n\npl.DataFrame(info)\n\n\n\n\nshape: (3, 5)\n\n\n\ndataset\n#rows\n#cols\n#Metadata cols\nSize (MB)\n\n\nstr\ni64\ni64\ni64\ni64\n\n\n\n\n\"orf\"\n81660\n726\n4\n239\n\n\n\"crispr\"\n51185\n263\n4\n54\n\n\n\"compound\"\n803853\n741\n4\n2400\n\n\n\n\n\n\n\nLet us now focus on the crispr dataset and use a regex to select the metadata columns. We will then sample rows and display the overview. Note that the collect() method enforces loading some data into memory.\n\n\nCode\ndata = pl.scan_parquet(filepaths[\"crispr\"])\ndata.select(pl.col(\"^Metadata.*$\").sample(n=5, seed=1)).collect()\n\n\n\n\nshape: (5, 4)\n\n\n\nMetadata_Source\nMetadata_Plate\nMetadata_Well\nMetadata_JCP2022\n\n\nstr\nstr\nstr\nstr\n\n\n\n\n\"source_13\"\n\"CP-CC9-R2-15\"\n\"D02\"\n\"JCP2022_800002\"\n\n\n\"source_13\"\n\"CP-CC9-R1-04\"\n\"J18\"\n\"JCP2022_800028\"\n\n\n\"source_13\"\n\"CP-CC9-R2-04\"\n\"J09\"\n\"JCP2022_807421\"\n\n\n\"source_13\"\n\"CP-CC9-R2-26\"\n\"L14\"\n\"JCP2022_807129\"\n\n\n\"source_13\"\n\"CP-CC9-R6-01\"\n\"C12\"\n\"JCP2022_806640\"\n\n\n\n\n\n\n\nThe following line excludes the metadata columns:\n\n\nCode\ndata_only = data.select(pl.all().exclude(\"^Metadata.*$\").sample(n=5, seed=1)).collect()\ndata_only\n\n\n\n\nshape: (5, 259)\n\n\n\nX_1\nX_2\nX_3\nX_4\nX_5\nX_6\nX_7\nX_8\nX_9\nX_10\nX_11\nX_12\nX_13\nX_14\nX_15\nX_16\nX_17\nX_18\nX_19\nX_20\nX_21\nX_22\nX_23\nX_24\nX_25\nX_26\nX_27\nX_28\nX_29\nX_30\nX_31\nX_32\nX_33\nX_34\nX_35\nX_36\nX_37\n…\nX_223\nX_224\nX_225\nX_226\nX_227\nX_228\nX_229\nX_230\nX_231\nX_232\nX_233\nX_234\nX_235\nX_236\nX_237\nX_238\nX_239\nX_240\nX_241\nX_242\nX_243\nX_244\nX_245\nX_246\nX_247\nX_248\nX_249\nX_250\nX_251\nX_252\nX_253\nX_254\nX_255\nX_256\nX_257\nX_258\nX_259\n\n\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\n…\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\n\n\n\n\n0.431689\n0.121776\n-0.288611\n1.199042\n-0.758412\n-0.466926\n-0.777705\n-0.081231\n-0.619822\n-1.27128\n-0.373444\n0.755662\n-0.271196\n-0.219682\n0.268569\n-0.831324\n-0.916929\n0.128514\n0.202126\n-0.448374\n0.57358\n-0.148984\n-0.451346\n-0.863105\n-0.519879\n-0.485649\n0.067051\n-0.461362\n-0.87479\n0.060438\n-0.86988\n-0.053304\n0.479346\n0.415922\n0.55612\n0.057157\n-0.486731\n…\n0.070464\n0.011686\n-0.071482\n0.047634\n-0.137811\n0.010114\n-0.146834\n0.028652\n0.048453\n0.015478\n-0.371927\n-0.318295\n-0.07663\n0.099552\n-0.067174\n0.324664\n0.11507\n0.07018\n0.149843\n0.090655\n-0.024452\n-0.167478\n-0.063188\n0.10028\n-0.20603\n-0.143531\n-0.042267\n-0.103231\n0.166172\n0.268637\n-0.249552\n-0.125842\n-0.010658\n0.148293\n-0.002996\n0.018602\n0.120415\n\n\n-0.286125\n-0.139647\n0.521229\n-0.130772\n-0.392223\n-0.478905\n-2.190718\n-0.910039\n-0.923397\n-0.89992\n0.809614\n0.195752\n1.051458\n-0.586142\n0.132069\n0.691497\n2.309921\n0.451202\n0.017881\n0.722985\n0.094764\n0.458089\n0.289687\n-0.005019\n-0.44384\n-0.292192\n-0.661437\n-0.480588\n-0.43835\n0.392833\n0.883042\n-0.183804\n-0.63443\n0.088329\n0.317562\n0.790481\n0.49558\n…\n0.12586\n0.150716\n0.092419\n0.070398\n-0.10096\n0.241489\n-0.02793\n-0.069464\n0.173498\n0.096578\n-0.006984\n-0.010409\n-0.122357\n-0.154975\n-0.264336\n-0.026424\n-0.107131\n-0.217108\n-0.076673\n-0.025199\n0.178872\n0.273566\n-0.011964\n-0.284162\n-0.07764\n-0.147836\n-0.030516\n0.039593\n-0.251191\n-0.145978\n-0.061276\n0.260967\n0.136172\n0.220407\n-0.016074\n0.24593\n-0.051766\n\n\n0.044537\n0.093762\n0.38071\n-0.078268\n-0.332677\n-0.492756\n-0.54244\n-0.751058\n0.28314\n0.772951\n-0.344511\n-0.291534\n-0.64803\n1.04816\n0.814905\n0.020586\n-1.699232\n-0.35928\n0.474136\n-0.500731\n0.16648\n0.460551\n0.773349\n-0.584125\n0.070497\n0.382738\n1.290578\n1.115024\n0.656066\n-0.211548\n0.615551\n1.202399\n0.61274\n0.467623\n0.826743\n0.98965\n0.515379\n…\n-0.035649\n0.084653\n-0.148614\n0.41456\n-0.035386\n0.039774\n0.222122\n0.127807\n0.212482\n-0.087575\n0.149949\n-0.146337\n0.031107\n0.048564\n-0.151519\n-0.256957\n-0.147494\n-0.051771\n0.000703\n-0.100694\n0.127297\n-0.159605\n0.056752\n0.079783\n-0.301415\n-0.033567\n-0.073402\n0.073441\n0.003454\n-0.065908\n0.003793\n0.017154\n0.122071\n0.031753\n-0.115469\n-0.183939\n-0.037042\n\n\n0.045477\n0.020634\n0.312316\n1.316\n-0.831466\n-1.536956\n0.495057\n-1.25451\n-0.417021\n0.099831\n0.010575\n0.815467\n-0.793362\n-0.602823\n-0.470462\n-1.901034\n-0.749613\n-0.03417\n-0.349764\n-0.109558\n0.50934\n0.937879\n-0.567808\n-0.361403\n0.07038\n0.428986\n0.178268\n-0.264072\n-1.08156\n0.484804\n0.257085\n-0.387199\n-0.594517\n-0.142474\n0.364982\n0.369385\n-0.033974\n…\n0.080806\n0.047688\n0.081428\n-0.072393\n-0.134251\n0.32516\n-0.013819\n-0.231218\n0.235347\n-0.099079\n-0.214146\n-0.088035\n0.279149\n0.235552\n0.056753\n-0.002605\n-0.121467\n-0.011054\n0.014276\n0.031513\n0.056525\n-0.204108\n0.056208\n-0.007412\n0.295334\n0.059559\n-0.072717\n0.143892\n-0.175082\n0.06916\n-0.240234\n-0.243179\n0.132553\n-0.10939\n-0.006807\n-0.081922\n-0.033631\n\n\n-0.128473\n-0.163732\n0.052351\n-3.2502\n0.237454\n0.327462\n2.975345\n1.074392\n-0.642075\n-0.309154\n-1.427569\n0.209862\n-0.207053\n-0.785397\n-1.690689\n0.57705\n1.286289\n-0.260824\n-0.066723\n-0.378312\n-0.107758\n0.58553\n0.723803\n-0.085321\n-0.899026\n-0.508275\n0.946614\n0.681252\n0.591428\n-0.058463\n-0.611216\n-0.249337\n0.151805\n-0.201767\n-0.364704\n-0.279569\n0.032865\n…\n-0.103084\n-0.092279\n0.061387\n-0.229078\n0.214459\n0.018508\n-0.164547\n0.170245\n-0.028671\n-0.024243\n0.116811\n0.03172\n0.010574\n0.014084\n0.15063\n-0.053592\n-0.297773\n-0.033743\n0.264092\n-0.030906\n-0.04306\n-0.126682\n-0.050824\n-0.011592\n0.082704\n-0.186133\n0.172641\n-0.056459\n0.190109\n0.06259\n0.093085\n-0.251115\n0.141207\n0.180379\n-0.006493\n-0.155394\n-0.013597\n\n\n\n\n\n\n\nFinally, we can convert this to pandas if we want to perform analyses with that tool. Keep in mind that this loads the entire dataframe into memory.\n\n\nCode\ndata_only.to_pandas()\n\n\n\n\n\n\n\n\n\n\nX_1\nX_2\nX_3\nX_4\nX_5\nX_6\nX_7\nX_8\nX_9\nX_10\n...\nX_250\nX_251\nX_252\nX_253\nX_254\nX_255\nX_256\nX_257\nX_258\nX_259\n\n\n\n\n0\n0.431689\n0.121776\n-0.288611\n1.199042\n-0.758412\n-0.466926\n-0.777705\n-0.081231\n-0.619822\n-1.271280\n...\n-0.103231\n0.166172\n0.268637\n-0.249552\n-0.125842\n-0.010658\n0.148293\n-0.002996\n0.018602\n0.120415\n\n\n1\n-0.286125\n-0.139647\n0.521229\n-0.130772\n-0.392223\n-0.478905\n-2.190718\n-0.910039\n-0.923397\n-0.899920\n...\n0.039593\n-0.251191\n-0.145978\n-0.061276\n0.260967\n0.136172\n0.220407\n-0.016074\n0.245930\n-0.051766\n\n\n2\n0.044537\n0.093762\n0.380710\n-0.078268\n-0.332677\n-0.492756\n-0.542440\n-0.751058\n0.283140\n0.772951\n...\n0.073441\n0.003454\n-0.065908\n0.003793\n0.017154\n0.122071\n0.031753\n-0.115469\n-0.183939\n-0.037042\n\n\n3\n0.045477\n0.020634\n0.312316\n1.316000\n-0.831466\n-1.536956\n0.495057\n-1.254510\n-0.417021\n0.099831\n...\n0.143892\n-0.175082\n0.069160\n-0.240234\n-0.243179\n0.132553\n-0.109390\n-0.006807\n-0.081922\n-0.033631\n\n\n4\n-0.128473\n-0.163732\n0.052351\n-3.250200\n0.237454\n0.327462\n2.975345\n1.074392\n-0.642075\n-0.309154\n...\n-0.056459\n0.190109\n0.062590\n0.093085\n-0.251115\n0.141207\n0.180379\n-0.006493\n-0.155394\n-0.013597\n\n\n\n\n5 rows × 259 columns",
    "crumbs": [
      "How-To Guides",
      "Retrieve JUMP profiles"
    ]
  },
  {
    "objectID": "howto/6_query_genes_externally.html",
    "href": "howto/6_query_genes_externally.html",
    "title": "Query information of genes",
    "section": "",
    "text": "This how-to focuses on linking gene names outside. Whilst not JUMP-specific, it is useful to fetch more information on perturbations that our analysis deem important without having to manually search them. We will use Biopython, this only explores a subset of the options, the full Entrez documentation, which contains all the options, is a useful reference to keep in hand..\n\n\nCode\nimport polars as pl\nfrom Bio import Entrez\nfrom broad_babel.query import get_mapper\n\n\nWe define\n\n\nCode\nEntrez.email = \"example@email.com\"\nfields = (\n    \"Name\",\n    \"Description\",\n    \"Summary\",\n    \"OtherDesignations\",  # This gives us synonyms\n)\n\n\nWe will use a set of genes that we found in a JUMP cluster as an example.\n\n\nCode\ngenes = (\"CHRM4\", \"SCAPER\", \"GPR176\", \"LY6K\")\n\n\nGet the\n\n\nCode\n# Get a dictionary that maps Gene symbols to Entrez IDs\nids = get_mapper(\n    query=genes,\n    input_column=\"standard_key\",\n    output_columns=\"standard_key,NCBI_Gene_ID\",\n)\n\n# Fetch the summaries for these genes\nentries = []\nfor id_ in ids.values():\n    stream = Entrez.esummary(db=\"gene\", id=id_)\n    record = Entrez.read(stream)\n\n    entries.append(\n        {k: record[\"DocumentSummarySet\"][\"DocumentSummary\"][0][k] for k in fields}\n    )\n\n\n\n\nCode\nwith pl.Config(fmt_str_lengths=1000):\n    print(pl.DataFrame(entries))\n\n\nshape: (4, 4)\n┌────────┬─────────────────────────────┬─────────────────────────────┬─────────────────────────────┐\n│ Name   ┆ Description                 ┆ Summary                     ┆ OtherDesignations           │\n│ ---    ┆ ---                         ┆ ---                         ┆ ---                         │\n│ str    ┆ str                         ┆ str                         ┆ str                         │\n╞════════╪═════════════════════════════╪═════════════════════════════╪═════════════════════════════╡\n│ GPR176 ┆ G protein-coupled receptor  ┆ Members of the G            ┆ G-protein coupled receptor  │\n│        ┆ 176                         ┆ protein-coupled receptor    ┆ 176|probable G-protein      │\n│        ┆                             ┆ family, such as GPR176, are ┆ coupled receptor 176        │\n│        ┆                             ┆ cell surface receptors      ┆                             │\n│        ┆                             ┆ involved in responses to    ┆                             │\n│        ┆                             ┆ hormones, growth factors,   ┆                             │\n│        ┆                             ┆ and neurotransmitters (Hata ┆                             │\n│        ┆                             ┆ et al., 1995 [PubMed        ┆                             │\n│        ┆                             ┆ 7893747]).[supplied by      ┆                             │\n│        ┆                             ┆ OMIM, Jul 2008]             ┆                             │\n│ CHRM4  ┆ cholinergic receptor        ┆ The muscarinic cholinergic  ┆ muscarinic acetylcholine    │\n│        ┆ muscarinic 4                ┆ receptors belong to a       ┆ receptor M4|acetylcholine   │\n│        ┆                             ┆ larger family of G          ┆ receptor, muscarinic 4      │\n│        ┆                             ┆ protein-coupled receptors.  ┆                             │\n│        ┆                             ┆ The functional diversity of ┆                             │\n│        ┆                             ┆ these receptors is defined  ┆                             │\n│        ┆                             ┆ by the binding of           ┆                             │\n│        ┆                             ┆ acetylcholine and includes  ┆                             │\n│        ┆                             ┆ cellular responses such as  ┆                             │\n│        ┆                             ┆ adenylate cyclase           ┆                             │\n│        ┆                             ┆ inhibition,                 ┆                             │\n│        ┆                             ┆ phosphoinositide            ┆                             │\n│        ┆                             ┆ degeneration, and potassium ┆                             │\n│        ┆                             ┆ channel mediation.          ┆                             │\n│        ┆                             ┆ Muscarinic receptors        ┆                             │\n│        ┆                             ┆ influence many effects of   ┆                             │\n│        ┆                             ┆ acetylcholine in the        ┆                             │\n│        ┆                             ┆ central and peripheral      ┆                             │\n│        ┆                             ┆ nervous system. The         ┆                             │\n│        ┆                             ┆ clinical implications of    ┆                             │\n│        ┆                             ┆ this receptor are unknown;  ┆                             │\n│        ┆                             ┆ however, mouse studies link ┆                             │\n│        ┆                             ┆ its function to adenylyl    ┆                             │\n│        ┆                             ┆ cyclase inhibition.         ┆                             │\n│        ┆                             ┆ [provided by RefSeq, Jul    ┆                             │\n│        ┆                             ┆ 2008]                       ┆                             │\n│ LY6K   ┆ lymphocyte antigen 6 family ┆ Predicted to be involved in ┆ lymphocyte antigen          │\n│        ┆ member K                    ┆ binding activity of sperm   ┆ 6K|cancer/testis antigen    │\n│        ┆                             ┆ to zona pellucida.          ┆ 97|lymphocyte antigen 6     │\n│        ┆                             ┆ Predicted to act upstream   ┆ complex, locus              │\n│        ┆                             ┆ of or within flagellated    ┆ K|up-regulated in lung      │\n│        ┆                             ┆ sperm motility. Predicted   ┆ cancer 10                   │\n│        ┆                             ┆ to be located in cell       ┆                             │\n│        ┆                             ┆ surface; cytoplasm; and     ┆                             │\n│        ┆                             ┆ plasma membrane. Predicted  ┆                             │\n│        ┆                             ┆ to be active in acrosomal   ┆                             │\n│        ┆                             ┆ vesicle. [provided by       ┆                             │\n│        ┆                             ┆ Alliance of Genome          ┆                             │\n│        ┆                             ┆ Resources, Apr 2022]        ┆                             │\n│ SCAPER ┆ S-phase cyclin A associated ┆ Predicted to enable nucleic ┆ S phase cyclin A-associated │\n│        ┆ protein in the ER           ┆ acid binding activity and   ┆ protein in the endoplasmic  │\n│        ┆                             ┆ zinc ion binding activity.  ┆ reticulum|zinc finger       │\n│        ┆                             ┆ Located in cytosol and      ┆ protein 291                 │\n│        ┆                             ┆ nuclear speck. [provided by ┆                             │\n│        ┆                             ┆ Alliance of Genome          ┆                             │\n│        ┆                             ┆ Resources, Apr 2022]        ┆                             │\n└────────┴─────────────────────────────┴─────────────────────────────┴─────────────────────────────┘",
    "crumbs": [
      "How-To Guides",
      "Query information of genes"
    ]
  }
]