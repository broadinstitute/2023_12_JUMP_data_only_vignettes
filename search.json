[
  {
    "objectID": "howto/3_calculate_activity.html",
    "href": "howto/3_calculate_activity.html",
    "title": "Calculate phenotypic activity",
    "section": "",
    "text": "A common first analysis for morphological datasets is the activity of the cells’ phenotypes. We will use the copairs package, which makes use of mean average precision to obtain a metric of replicability for any set of morphological profiles. In other words, it indicates how similar a given set of compounds are, relative to their negative controls, which is usually cells that have experienced no perturbation.\n\n\nCode\nimport polars as pl\nimport polars.selectors as cs\nimport seaborn as sns\nfrom broad_babel.query import get_mapper\nfrom copairs.map import average_precision\n\n\nWe will be using the CRISPR dataset specificed in our index csv, but we will select a subset of perturbations and the controls present.\n\n\nCode\nINDEX_FILE = \"https://raw.githubusercontent.com/jump-cellpainting/datasets/50cd2ab93749ccbdb0919d3adf9277c14b6343dd/manifests/profile_index.csv\"\nCRISPR_URL = pl.read_csv(INDEX_FILE).filter(pl.col(\"subset\")==\"crispr\").item(0,\"url\")\nprofiles = pl.scan_parquet(CRISPR_URL)\n\n\nSample perturbations and add known negative control.\n\n\nCode\njcp_ids = profiles.select(pl.col(\"Metadata_JCP2022\")).unique().collect().to_series().sort()\nsubsample = jcp_ids.sample(10, seed=42)\nsubsample = (*subsample, \"JCP2022_800002\") # Add the only control in CRISPR data\nprofiles_subset = profiles.filter(pl.col(\"Metadata_JCP2022\").is_in(subsample)).collect()\nunique_plates = profiles_subset.filter(pl.col(\"Metadata_JCP2022\")!=subsample[-1])[\"Metadata_Plate\"].unique()\nperts_controls = profiles_subset.filter(pl.col(\"Metadata_Plate\").is_in(unique_plates))\nwith pl.Config() as cfg:\n    cfg.set_tbl_cols(7) # Limit the number of columns printed\n    perts_controls.head()\n\n\nNow we create a mapper to label treatments and controls. See the previous tutorial for details on fetching metadata.\n\n\nCode\npert_mapper = get_mapper(subsample, input_column=\"JCP2022\", output_columns=\"JCP2022,pert_type\")\nperts_controls_annotated = perts_controls.with_columns(pl.col(\"Metadata_JCP2022\").replace(pert_mapper).alias(\"pert_type\"))\n\n\nFinally we use the parameters from . See the copairs wiki for more details on the parameters that copairs requires.\n\n\nCode\npos_sameby = [\"Metadata_JCP2022\"] # We want to match perturbations\npos_diffby = []\nneg_sameby = []\nneg_diffby = [\"pert_type\"]\nbatch_size = 20000\n\nmetadata_selector = cs.starts_with((\"Metadata\", \"pert_type\"))\nmeta = perts_controls_annotated.select(metadata_selector)\nfeatures = perts_controls_annotated.select(~metadata_selector)\n\nresult = average_precision(meta.to_pandas(), features.to_numpy(), pos_sameby, pos_diffby, neg_sameby, neg_diffby, batch_size)\nresult = pl.DataFrame(result) # We convert back to polars because we prefer how it prints dataframes\nresult.head() \n\n\n\n\n\n\n\n\n\n\nshape: (5, 8)\n\n\n\nMetadata_Source\nMetadata_Plate\nMetadata_Well\nMetadata_JCP2022\npert_type\nn_pos_pairs\nn_total_pairs\naverage_precision\n\n\nstr\nstr\nstr\nstr\nstr\ni64\ni64\nf64\n\n\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"I23\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.920554\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"J02\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.920515\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"L23\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.931227\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"O23\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.92076\n\n\n\"source_13\"\n\"CP-CC9-R1-05\"\n\"M02\"\n\"JCP2022_800002\"\n\"negcon\"\n419\n471\n0.951237\n\n\n\n\n\n\n\nThe result of copairs is a dataframe containing, in addition to the original metadata, the average precision with which perturbations were retrieved. Perturbations that look more similar to each other than to the negative controls in the plates present in the same plates will be higher. Perturbations that do not differentiate themselves against negative controls will be closer to zero.\nTo wrap up we pull the standard gene symbol and plot the distribution of average precision.\n\n\nCode\nname_mapper = get_mapper(subsample, input_column=\"JCP2022\", output_columns=\"JCP2022,standard_key\")\n\nto_plot = result.filter(pl.col(\"pert_type\")==\"trt\").with_columns(pl.col(\"Metadata_JCP2022\").replace(name_mapper).alias(\"Perturbed gene\"))\n\n# Plotting\nsns.stripplot(data=to_plot.to_pandas(), x=\"average_precision\", y=\"Perturbed gene\")\n\n\n\n\n\n\n\n\n\nWe can see that only some perturbations can be easily retrieved when compared to negative controls, in this case KIF16B and CDK20. For a deeper dive into how mean Average Precision (mAP) works, you can explore this notebook.",
    "crumbs": [
      "How-To Guides",
      "Calculate phenotypic activity"
    ]
  },
  {
    "objectID": "howto/display_perturbation_images.html",
    "href": "howto/display_perturbation_images.html",
    "title": "Plot all channels for one site",
    "section": "",
    "text": "This notebook demonstrates how to retrieve and plot all channels for one site using jump_portrait.\n\n\nCode\nimport matplotlib.colors as mpl  # noqa: CPY001\nimport numpy as np\nimport polars as pl\nfrom jump_portrait.fetch import get_item_location_info, get_jump_image\nfrom matplotlib import pyplot as plt\n\n\nFirst, we need to get location information telling us where all images corresponding to a specific perturbation can be found. We will use the “get_item_location” function from jump_portrait for this.\nHere we retrieve image locations for the “RAB30” gene:\n\n\nCode\ngene_info = get_item_location_info(\"RAB30\")\ngene_info.shape\n\n\nDownloading data from 'https://github.com/jump-cellpainting/datasets/raw/c68deb2babc83747e6b14d8a77e5655138a6086a/metadata/well.csv.gz' to file '/home/runner/.cache/pooch/4efbf4dd3dd9aaecc8ccb9fc3c6b4122-well.csv.gz'.\nDownloading data from 'https://github.com/jump-cellpainting/datasets/raw/c68deb2babc83747e6b14d8a77e5655138a6086a/metadata/plate.csv.gz' to file '/home/runner/.cache/pooch/a530bb82de29e39332bdef6f29397769-plate.csv.gz'.\n\n\n(90, 28)\n\n\nThere are 90 images: 9 sites/well X 5 replicate wells X 2 data types (CRISPR & ORF).\nWe can also retrieve locations for compound data. By default, the function assumes a query by INCHI key. We can also query by JCP ID by specifying the query column:\n\n\nCode\ncmpd_info_byinchi = get_item_location_info(\"CLETVKMYAXARPO-UHFFFAOYSA-N\")\ncmpd_info_byjcp = get_item_location_info(\"JCP2022_011844\", input_column=\"JCP2022\")\n\nprint(cmpd_info_byinchi.shape)\nprint(cmpd_info_byjcp.shape)\n\n\n(34, 28)\n(34, 28)\n\n\nThere are 34 sites corresponding to this compound.\nWe’ve written a function to display all channels for a specific image. Note that this is just one possible way to display images - we’ve included the function here so that you can modify it to suit your own needs.\n\n\nCode\ndef display_site(source: str, batch: str, plate: str, well: str, site: str, label: str, int_percentile: float) -&gt; None:\n    \"\"\"Plot all channels from one image.\n\n    Parameters\n    ----------\n    source : String\n        Source ID for image of interest.\n    batch : String\n        Batch ID for image of interest.\n    plate : String\n        Plate ID for image of interest.\n    well : String\n        Well ID for image of interest.\n    site : String\n        Site ID for image of interest.\n    label : String\n        Label to display in lower left corner.\n    int_percentile: float\n        Rescale the image from 0 - this percentile of intensity values.\n\n    \"\"\"\n    channels = [\"DNA\", \"ER\", \"Mito\", \"AGP\", \"RNA\"]\n\n    n_rows = 2\n    n_cols = 3\n\n    # Make images\n    axes = plt.subplots(n_rows, n_cols, figsize=(2.6 * n_cols, 2.6 * n_rows))[1]\n    axes = axes.ravel()\n    counter = 0\n\n    for channel in channels:\n        if channel == \"ER\":\n            cmap = mpl.LinearSegmentedColormap.from_list(\"green_cmap\", [\"#000\", \"#65fe08\"])\n        elif channel == \"DNA\":\n            cmap = mpl.LinearSegmentedColormap.from_list(\"green_cmap\", [\"#000\", \"#0000FF\"])\n        elif channel == \"Mito\":\n            cmap = mpl.LinearSegmentedColormap.from_list(\"green_cmap\", [\"#000\", \"#FF0000\"])\n        elif channel == \"AGP\":\n            cmap = mpl.LinearSegmentedColormap.from_list(\"green_cmap\", [\"#000\", \"#FFFF00\"])\n        elif channel == \"RNA\":\n            cmap = mpl.LinearSegmentedColormap.from_list(\"green_cmap\", [\"#000\", \"#FFA500\"])\n        else:\n            cmap = \"gray\"\n\n        img = get_jump_image(source, batch, plate, well, channel, site, None)\n\n        ax = axes[counter]\n        ax.imshow(img, vmin=0, vmax=np.percentile(img, int_percentile), cmap=cmap)\n        ax.axis(\"off\")\n\n        # Add channel name label in the top left corner\n        ax.text(\n            0.05, 0.95, channel,\n            horizontalalignment='left',\n            verticalalignment='top',\n            fontsize=18,\n            color='black',\n            bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', boxstyle='round,pad=0.3'),\n            transform=ax.transAxes\n        )\n        \n        counter += 1\n\n    # put label in last subplot\n    ax = axes[counter]\n    ax.text(\n        0.5,\n        0.5,\n        label,\n        horizontalalignment=\"center\",\n        verticalalignment=\"center\",\n        fontsize=20,\n        color=\"black\",\n        transform=ax.transAxes,\n    )\n    ax.axis(\"off\")\n\n    # show plot\n    plt.tight_layout()\n    plt.show()\n\n\nWe can get the required location parameters from the location info that we retrieved earlier. Here we get parameters for the first site in the JCP compound results:\n\n\nCode\nsource, batch, plate, well, site, *rest = cmpd_info_byjcp.row(0)\n\n\nNext, we define the label and make the plot:\n\n\nCode\nlabel = f\"JCP2022_011844\\n\\nplate: {plate}\\nwell: {well}\\nsite: {site}\"\ndisplay_site(source, batch, plate, well, site, label, 99.5)\n\n\n\n\n\n\n\n\n\nHere, we plot one of the RAB30 ORF images:\n\n\nCode\nsource, batch, plate, well, site, *rest = gene_info.filter(pl.col(\"Metadata_PlateType\") == \"ORF\").row(0)\nlabel = f\"RAB30 (ORF)\\n\\nplate: {plate}\\nwell: {well}\\nsite: {site}\"\ndisplay_site(source, batch, plate, well, site, label, 99.5)\n\n\n\n\n\n\n\n\n\nAnd for CRISPR:\n\n\nCode\nsource, batch, plate, well, site, *rest = gene_info.filter(pl.col(\"Metadata_PlateType\") == \"CRISPR\").row(0)\nlabel = f\"RAB30 (CRISPR)\\n\\nplate: {plate}\\nwell: {well}\\nsite: {site}\"\ndisplay_site(source, batch, plate, well, site, label, 99.5)",
    "crumbs": [
      "How-To Guides",
      "Plot all channels for one site"
    ]
  },
  {
    "objectID": "explanations/FAQ.html",
    "href": "explanations/FAQ.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Frequently Asked Questions\n\nAnalyses\n\nHow can I reproduce an environment to explore JUMP data?\n\nData\n\nDoes JUMP contain X compound/gene?\nWhere are the datasets specification?\nWhy are some images with corresponding images but no downstream analysis?\nWhy do some perturbations have so many replicates\nHow were the profiles created?\nDo we we expect one JCP to have multiple targets?\nDo JCPs within either the CRISPR or ORF share the same gene?\nWeb interfaces\nFrequently Asked Questions and links to their answers. They are grouped based on whether they pertain to data, libraries or analyses.",
    "crumbs": [
      "Explanations",
      "Frequently Asked Questions"
    ]
  },
  {
    "objectID": "explanations/FAQ.html#analyses",
    "href": "explanations/FAQ.html#analyses",
    "title": "Frequently Asked Questions",
    "section": "Analyses",
    "text": "Analyses\n\n\nHow can I reproduce an environment to explore JUMP data?\n(WIP) The easiest way to set things up will be installing from pip in your enviromnment of choice:\npip install jump-deps",
    "crumbs": [
      "Explanations",
      "Frequently Asked Questions"
    ]
  },
  {
    "objectID": "explanations/FAQ.html#data",
    "href": "explanations/FAQ.html#data",
    "title": "Frequently Asked Questions",
    "section": "Data",
    "text": "Data\n\n\nDoes JUMP contain X compound/gene?\nThe easiest way to find out is querying your dataset using this web tool. Alternatively, you can explore the metadata tables on the datasets repository.\n\n\n\nWhere are the datasets specification?\nThe main resource to understand the technicalities of the JUMP datasets collection and assembly is on this repo.\n\n\n\nWhy are some images with corresponding images but no downstream analysis?\nSome plates failed Quality Control (QC) but we kept them because they may be useful for developing QC methods.\n\n\n\nWhy do some perturbations have so many replicates\nMost plates contain 16 negative control wells, while some have as many as 28 wells. One replicate of four of the compound positive controls are added to wells O23, O24, P23 and P24. The remaining wells contain ORF treatments, with a single replicate of each per plate map and with five replicate plates produced per plate map (issue).\n\n\n\nHow were the profiles created?\nWe used snakemake and pycytominer to generate these. The details can be found in this repo.\n\n\n\nDo we we expect one JCP to have multiple targets?\nYes, there will be many with multiple targets. For instance, JCP2022_050797 (quinidine/quinine) has the targets KCNK1 and KCNN4.\nTwo were considered to be two different compounds because they had different names and broad_sample names. But after all the data cleanup steps, they ended up being the same. Hence two different entries.\n\n\n\nDo JCPs within either the CRISPR or ORF share the same gene?\nIn CRISPR each JCP ID corresponds to a different gene. But in ORF there are sometimes multiple reagents targeting the same gene. In this case, we compute consensus profiles at the gene level (more info here).\n\n\n\nWeb interfaces\n\nWhat is the source of the replicability metric?\nThese two files (ORF and CRISPR) contain the mAP and corrected p values for replicate retrieval. They won’t contain all ORF and CRISPR reagents because so of them were filtered out for qc reasons.\nX_Feature: For each row, is the Feature value an average for all the cells in the Metadata_image using the listed Mask? Or is it associated with a single cell in that image?\nAny Feature is the average of all cells and all replicates (typically four in total) for the specific mask and feature.\nHow are Statistic and Median calculated for each row? Are they calculated in relation to the average of the “Feature” values for the negative controls in the same plate?\n\nStatistic is the probability of a given distribution (four replicates) to occur relative to their negative controls (in the four plates, typically each replicate is in an independent plate).\nMedian is the median feature across all (~4) replicates. Each of these replicates’ value was in turn the mean of all the sites and cells in a given well.",
    "crumbs": [
      "Explanations",
      "Frequently Asked Questions"
    ]
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "Additional uses",
    "section": "",
    "text": "Additional uses\n\nFocal point for JUMP information and data analysis pipelines.\n\n\nAdditional uses\nThis repository can be used as a way to install essential dependencies for an exploratory analysis of JUMP morphological data."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Overview\nThis is work in progress. The purpose of this resource is to concentrate all the useful and up-to-date information necessary to make use of JUMP. It aims to summarise the most useful information, including examples, guides, know-hows and links to more material for deeper dives into data acquisition, processing, sharing and visualisation.\n\n\nI just want to access the web tools\nHere you can find the up-to-date web tools to explore JUMP from your browser.\n\n\nI am a developer interested in using and writing programatic tools for JUMP\nOur monorepo hosts Python libraries that may help you access JUMP data in a high-throughput manner.\n\n\nWhy yet another resource?\nIts secondary (yet highly important purpose) is to minimise friction for developers, technical writers and biologists to produce and access novel insights and tools. We believe complexity is one of the biggest challenges we face, as it hampers collaboration and novel biological insights. We aim to make this the one-stop shop for the vast majority of JUMP questions, be it computational or biological.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "explanations/Resources.html",
    "href": "explanations/Resources.html",
    "title": "Available resources",
    "section": "",
    "text": "Available resources\n\n\n\nAvailable resources\n\nHome website: Access news and related publications.\nWe provide Open Source Web “JUMPer” interfaces for all three datasets (CRISPR, ORF and Compound). For more details follow this link.\nArdigen provides a website to explore a representation (requires creating a free account).\nSpring Science also provides a website for data exploration (account needed).",
    "crumbs": [
      "Explanations",
      "Available resources"
    ]
  },
  {
    "objectID": "howto/2_add_metadata.html",
    "href": "howto/2_add_metadata.html",
    "title": "Incorporate metadata into profiles",
    "section": "",
    "text": "A very common task when processing morphological profiles is knowing which ones are treatments and which ones are controls. Here we will explore how we can use broad-babel to accomplish this task.\n\n\nCode\nimport polars as pl\nfrom broad_babel.query import get_mapper\n\n\nDownloading data from 'https://zenodo.org/records/12211976/files/babel.db' to file '/home/runner/.cache/pooch/2eaa6a2f4915f72d7100683f53982ed8-babel.db'.\n\n\nWe will be using the CRISPR dataset specificed in our index csv.\n\n\nCode\nINDEX_FILE = \"https://raw.githubusercontent.com/jump-cellpainting/datasets/50cd2ab93749ccbdb0919d3adf9277c14b6343dd/manifests/profile_index.csv\"\nCRISPR_URL = pl.read_csv(INDEX_FILE).filter(pl.col(\"subset\")==\"crispr\").item(0,\"url\")\nprofiles = pl.scan_parquet(CRISPR_URL)\nprint(profiles.collect_schema().names()[:6])\n\n\n['Metadata_Source', 'Metadata_Plate', 'Metadata_Well', 'Metadata_JCP2022', 'X_1', 'X_2']\n\n\nFor simplicity the contents of our processed profiles are minimal: “The profile origin” (source, plate and well) and the unique JUMP identifier for that perturbation. We will use broad-babel to further expand on this metadata, but for simplicity’s sake let us sample subset of data.\n\n\nCode\njcp_ids = profiles.select(pl.col(\"Metadata_JCP2022\")).unique().collect().to_series().sort()\nsubsample = jcp_ids.sample(10, seed=42)\n# Add a well-known control\nsubsample = (*subsample, \"JCP2022_800002\")\nsubsample\n\n\n('JCP2022_801270',\n 'JCP2022_802425',\n 'JCP2022_802356',\n 'JCP2022_805808',\n 'JCP2022_804300',\n 'JCP2022_801205',\n 'JCP2022_802539',\n 'JCP2022_803663',\n 'JCP2022_800116',\n 'JCP2022_801847',\n 'JCP2022_800002')\n\n\nWe will use these JUMP ids to obtain a mapper that indicates the perturbation type (trt, negcon or, rarely, poscon)\n\n\nCode\npert_mapper = get_mapper(subsample, input_column=\"JCP2022\", output_columns=\"JCP2022,pert_type\")\npert_mapper\n\n\n{'JCP2022_800116': 'trt',\n 'JCP2022_805808': 'trt',\n 'JCP2022_802425': 'trt',\n 'JCP2022_803663': 'trt',\n 'JCP2022_802539': 'trt',\n 'JCP2022_801847': 'trt',\n 'JCP2022_800002': 'negcon',\n 'JCP2022_804300': 'trt',\n 'JCP2022_802356': 'trt',\n 'JCP2022_801270': 'trt',\n 'JCP2022_801205': 'trt'}\n\n\nA couple of important notes about broad_babel’s get mapper and other functions: - these must be fed tuples, as these are cached and provide significant speed-ups for repeated calls - ‘get-mapper’ works for datasets for up to a few tens of thousands of samples. If you try to use it to get a mapper for the entirety of the ‘compounds’ dataset it is likely to fail. For these cases we suggest the more general function ‘run_query’. You can read more on this and other use-cases on Babel’s readme.\nWe will now repeat the process to get their ‘standard’ name\n\n\nCode\nname_mapper = get_mapper((*subsample, \"JCP2022_800002\"), input_column=\"JCP2022\", output_columns=\"JCP2022,standard_key\")\nname_mapper\n\n\n{'JCP2022_803663': 'KIF16B',\n 'JCP2022_804300': 'MSX1',\n 'JCP2022_800002': 'non-targeting',\n 'JCP2022_805808': 'RAD51B',\n 'JCP2022_801847': 'DMRT2',\n 'JCP2022_802425': 'FLNC',\n 'JCP2022_802539': 'G6PC',\n 'JCP2022_801205': 'CDK20',\n 'JCP2022_800116': 'ACOT11',\n 'JCP2022_801270': 'CFB',\n 'JCP2022_802356': 'FDX1'}\n\n\nTo wrap up, we will fetch all the available profiles for these perturbations and use the mappers to add the missing metadata. We also select a few features to showcase how how selection can be performed in polars.\n\n\nCode\nsubsample_profiles = profiles.filter(pl.col(\"Metadata_JCP2022\").is_in(subsample)).collect()\nprofiles_with_meta = subsample_profiles.with_columns(pl.col(\"Metadata_JCP2022\").replace(pert_mapper).alias(\"pert_type\"),\n                                pl.col(\"Metadata_JCP2022\").replace(name_mapper).alias(\"name\"))\nprofiles_with_meta.select(pl.col((\"name\",\"pert_type\", \"^Metadata.*$\", \"^X_[0-3]$\"))).sort(by=\"pert_type\")\n\n\n\n\nshape: (2_806, 9)\n\n\n\nname\npert_type\nMetadata_Source\nMetadata_Plate\nMetadata_Well\nMetadata_JCP2022\nX_1\nX_2\nX_3\n\n\nstr\nstr\nstr\nstr\nstr\nstr\nf32\nf32\nf32\n\n\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"A02\"\n\"JCP2022_800002\"\n-0.223417\n-0.049487\n-0.826231\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"L23\"\n\"JCP2022_800002\"\n-0.079349\n-0.016958\n-0.277558\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"I23\"\n\"JCP2022_800002\"\n-0.023832\n-0.00537\n-0.29832\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"J02\"\n\"JCP2022_800002\"\n-0.169491\n-0.023422\n-0.088187\n\n\n\"non-targeting\"\n\"negcon\"\n\"source_13\"\n\"CP-CC9-R1-01\"\n\"O23\"\n\"JCP2022_800002\"\n-0.295112\n-0.124241\n1.055193\n\n\n…\n…\n…\n…\n…\n…\n…\n…\n…\n\n\n\"CFB\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R5-19\"\n\"G12\"\n\"JCP2022_801270\"\n0.023277\n0.021747\n-0.914867\n\n\n\"DMRT2\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R5-21\"\n\"C10\"\n\"JCP2022_801847\"\n-0.208865\n-0.046884\n0.845933\n\n\n\"MSX1\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R5-24\"\n\"C03\"\n\"JCP2022_804300\"\n-0.003333\n0.053181\n0.078227\n\n\n\"CFB\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R6-19\"\n\"G12\"\n\"JCP2022_801270\"\n0.18701\n0.072405\n0.381239\n\n\n\"CFB\"\n\"trt\"\n\"source_13\"\n\"CP-CC9-R7-19\"\n\"G12\"\n\"JCP2022_801270\"\n0.051818\n-0.129935\n-0.481606",
    "crumbs": [
      "How-To Guides",
      "Incorporate metadata into profiles"
    ]
  },
  {
    "objectID": "howto/1_tutorial_basic.html",
    "href": "howto/1_tutorial_basic.html",
    "title": "Access JUMP profiles",
    "section": "",
    "text": "This is a tutorial on how to access profiles from the JUMP Cell Painting datasets. We will use polars to fetch the data frames lazily, with the help of s3fs and pyarrow. We prefer lazy loading because the data can be too big to be handled in memory.\n\n\nCode\nimport polars as pl\n\n\nThe shapes of the available datasets are:\n\ncpg0016-jump[crispr]: CRISPR knockouts genetic perturbations.\ncpg0016-jump[orf]: Overexpression genetic perturbations.\ncpg0016-jump[compound]: Chemical perturbations.\n\nTheir explicit location is determined by the transformations that produce the datasets. The aws paths of the dataframes are built from a prefix below:\n\n\nCode\nINDEX_FILE = \"https://raw.githubusercontent.com/jump-cellpainting/datasets/50cd2ab93749ccbdb0919d3adf9277c14b6343dd/manifests/profile_index.csv\"\n\n\nWe use a version-controlled csv to release the latest corrected profiles\n\n\nCode\nprofile_index = pl.read_csv(INDEX_FILE)\nprofile_index.head()\n\n\n\n\nshape: (5, 3)\n\n\n\nsubset\nurl\netag\n\n\nstr\nstr\nstr\n\n\n\n\n\"orf\"\n\"https://cellpainting-gallery.s…\n\"c05a241135dcedda4e9cc639480b3f…\n\n\n\"crispr\"\n\"https://cellpainting-gallery.s…\n\"4c59782c0dd5244f67d14323e83258…\n\n\n\"compound\"\n\"https://cellpainting-gallery.s…\n\"1368a48ddbd4c44b1bfbc084591aaf…\n\n\n\"orf_interpretable\"\n\"https://cellpainting-gallery.s…\n\"97b0c31d7d678ca2a5e2353df5799f…\n\n\n\"crispr_interpretable\"\n\"https://cellpainting-gallery.s…\n\"90b08b824c06bcf16dfc5e788e74f0…\n\n\n\n\n\n\n\nWe do not need the ‘etag’ (used to check file integrity) column nor the ‘interpretable’ (i.e., before major modifications)\n\n\nCode\nselected_profiles = profile_index.filter(\n    pl.col(\"subset\").is_in((\"crispr\", \"orf\", \"compound\"))\n).select(pl.exclude(\"etag\"))\nfilepaths = dict(selected_profiles.iter_rows())\nprint(filepaths)\n\n\n{'orf': 'https://cellpainting-gallery.s3.amazonaws.com/cpg0016-jump-assembled/source_all/workspace/profiles/jump-profiling-recipe_2024_a917fa7/ORF/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony.parquet', 'crispr': 'https://cellpainting-gallery.s3.amazonaws.com/cpg0016-jump-assembled/source_all/workspace/profiles/jump-profiling-recipe_2024_a917fa7/CRISPR/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony_PCA_corrected/profiles_wellpos_cc_var_mad_outlier_featselect_sphering_harmony_PCA_corrected.parquet', 'compound': 'https://cellpainting-gallery.s3.amazonaws.com/cpg0016-jump-assembled/source_all/workspace/profiles/jump-profiling-recipe_2024_a917fa7/COMPOUND/profiles_var_mad_int_featselect_harmony/profiles_var_mad_int_featselect_harmony.parquet'}\n\n\nWe will lazy-load the dataframes and print the number of rows and columns\n\n\nCode\ninfo = {k: [] for k in (\"dataset\", \"#rows\", \"#cols\", \"#Metadata cols\", \"Size (MB)\")}\nfor name, path in filepaths.items():\n    data = pl.scan_parquet(path)\n    n_rows = data.select(pl.len()).collect().item()\n    schema = data.collect_schema()\n    metadata_cols = [col for col in schema.keys() if col.startswith(\"Metadata\")]\n    n_cols = schema.len()\n    n_meta_cols = len(metadata_cols)\n    estimated_size = int(round(4.03 * n_rows * n_cols / 1e6, 0))  # B -&gt; MB\n    for k, v in zip(info.keys(), (name, n_rows, n_cols, n_meta_cols, estimated_size)):\n        info[k].append(v)\n\npl.DataFrame(info)\n\n\n\n\nshape: (3, 5)\n\n\n\ndataset\n#rows\n#cols\n#Metadata cols\nSize (MB)\n\n\nstr\ni64\ni64\ni64\ni64\n\n\n\n\n\"orf\"\n81660\n726\n4\n239\n\n\n\"crispr\"\n51185\n263\n4\n54\n\n\n\"compound\"\n803853\n741\n4\n2400\n\n\n\n\n\n\n\nLet us now focus on the crispr dataset and use a regex to select the metadata columns. We will then sample rows and display the overview. Note that the collect() method enforces loading some data into memory.\n\n\nCode\ndata = pl.scan_parquet(filepaths[\"crispr\"])\ndata.select(pl.col(\"^Metadata.*$\").sample(n=5, seed=1)).collect()\n\n\n\n\nshape: (5, 4)\n\n\n\nMetadata_Source\nMetadata_Plate\nMetadata_Well\nMetadata_JCP2022\n\n\nstr\nstr\nstr\nstr\n\n\n\n\n\"source_13\"\n\"CP-CC9-R2-15\"\n\"D02\"\n\"JCP2022_800002\"\n\n\n\"source_13\"\n\"CP-CC9-R1-04\"\n\"J18\"\n\"JCP2022_800028\"\n\n\n\"source_13\"\n\"CP-CC9-R2-04\"\n\"J09\"\n\"JCP2022_807421\"\n\n\n\"source_13\"\n\"CP-CC9-R2-26\"\n\"L14\"\n\"JCP2022_807129\"\n\n\n\"source_13\"\n\"CP-CC9-R6-01\"\n\"C12\"\n\"JCP2022_806640\"\n\n\n\n\n\n\n\nThe following line excludes the metadata columns:\n\n\nCode\ndata_only = data.select(pl.all().exclude(\"^Metadata.*$\").sample(n=5, seed=1)).collect()\ndata_only\n\n\n\n\nshape: (5, 259)\n\n\n\nX_1\nX_2\nX_3\nX_4\nX_5\nX_6\nX_7\nX_8\nX_9\nX_10\nX_11\nX_12\nX_13\nX_14\nX_15\nX_16\nX_17\nX_18\nX_19\nX_20\nX_21\nX_22\nX_23\nX_24\nX_25\nX_26\nX_27\nX_28\nX_29\nX_30\nX_31\nX_32\nX_33\nX_34\nX_35\nX_36\nX_37\n…\nX_223\nX_224\nX_225\nX_226\nX_227\nX_228\nX_229\nX_230\nX_231\nX_232\nX_233\nX_234\nX_235\nX_236\nX_237\nX_238\nX_239\nX_240\nX_241\nX_242\nX_243\nX_244\nX_245\nX_246\nX_247\nX_248\nX_249\nX_250\nX_251\nX_252\nX_253\nX_254\nX_255\nX_256\nX_257\nX_258\nX_259\n\n\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\n…\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\nf32\n\n\n\n\n0.431689\n0.121776\n-0.288611\n1.199042\n-0.758412\n-0.466926\n-0.777705\n-0.081231\n-0.619822\n-1.27128\n-0.373444\n0.755662\n-0.271196\n-0.219682\n0.268569\n-0.831324\n-0.916929\n0.128514\n0.202126\n-0.448374\n0.57358\n-0.148984\n-0.451346\n-0.863105\n-0.519879\n-0.485649\n0.067051\n-0.461362\n-0.87479\n0.060438\n-0.86988\n-0.053304\n0.479346\n0.415922\n0.55612\n0.057157\n-0.486731\n…\n0.070464\n0.011686\n-0.071482\n0.047634\n-0.137811\n0.010114\n-0.146834\n0.028652\n0.048453\n0.015478\n-0.371927\n-0.318295\n-0.07663\n0.099552\n-0.067174\n0.324664\n0.11507\n0.07018\n0.149843\n0.090655\n-0.024452\n-0.167478\n-0.063188\n0.10028\n-0.20603\n-0.143531\n-0.042267\n-0.103231\n0.166172\n0.268637\n-0.249552\n-0.125842\n-0.010658\n0.148293\n-0.002996\n0.018602\n0.120415\n\n\n-0.286125\n-0.139647\n0.521229\n-0.130772\n-0.392223\n-0.478905\n-2.190718\n-0.910039\n-0.923397\n-0.89992\n0.809614\n0.195752\n1.051458\n-0.586142\n0.132069\n0.691497\n2.309921\n0.451202\n0.017881\n0.722985\n0.094764\n0.458089\n0.289687\n-0.005019\n-0.44384\n-0.292192\n-0.661437\n-0.480588\n-0.43835\n0.392833\n0.883042\n-0.183804\n-0.63443\n0.088329\n0.317562\n0.790481\n0.49558\n…\n0.12586\n0.150716\n0.092419\n0.070398\n-0.10096\n0.241489\n-0.02793\n-0.069464\n0.173498\n0.096578\n-0.006984\n-0.010409\n-0.122357\n-0.154975\n-0.264336\n-0.026424\n-0.107131\n-0.217108\n-0.076673\n-0.025199\n0.178872\n0.273566\n-0.011964\n-0.284162\n-0.07764\n-0.147836\n-0.030516\n0.039593\n-0.251191\n-0.145978\n-0.061276\n0.260967\n0.136172\n0.220407\n-0.016074\n0.24593\n-0.051766\n\n\n0.044537\n0.093762\n0.38071\n-0.078268\n-0.332677\n-0.492756\n-0.54244\n-0.751058\n0.28314\n0.772951\n-0.344511\n-0.291534\n-0.64803\n1.04816\n0.814905\n0.020586\n-1.699232\n-0.35928\n0.474136\n-0.500731\n0.16648\n0.460551\n0.773349\n-0.584125\n0.070497\n0.382738\n1.290578\n1.115024\n0.656066\n-0.211548\n0.615551\n1.202399\n0.61274\n0.467623\n0.826743\n0.98965\n0.515379\n…\n-0.035649\n0.084653\n-0.148614\n0.41456\n-0.035386\n0.039774\n0.222122\n0.127807\n0.212482\n-0.087575\n0.149949\n-0.146337\n0.031107\n0.048564\n-0.151519\n-0.256957\n-0.147494\n-0.051771\n0.000703\n-0.100694\n0.127297\n-0.159605\n0.056752\n0.079783\n-0.301415\n-0.033567\n-0.073402\n0.073441\n0.003454\n-0.065908\n0.003793\n0.017154\n0.122071\n0.031753\n-0.115469\n-0.183939\n-0.037042\n\n\n0.045477\n0.020634\n0.312316\n1.316\n-0.831466\n-1.536956\n0.495057\n-1.25451\n-0.417021\n0.099831\n0.010575\n0.815467\n-0.793362\n-0.602823\n-0.470462\n-1.901034\n-0.749613\n-0.03417\n-0.349764\n-0.109558\n0.50934\n0.937879\n-0.567808\n-0.361403\n0.07038\n0.428986\n0.178268\n-0.264072\n-1.08156\n0.484804\n0.257085\n-0.387199\n-0.594517\n-0.142474\n0.364982\n0.369385\n-0.033974\n…\n0.080806\n0.047688\n0.081428\n-0.072393\n-0.134251\n0.32516\n-0.013819\n-0.231218\n0.235347\n-0.099079\n-0.214146\n-0.088035\n0.279149\n0.235552\n0.056753\n-0.002605\n-0.121467\n-0.011054\n0.014276\n0.031513\n0.056525\n-0.204108\n0.056208\n-0.007412\n0.295334\n0.059559\n-0.072717\n0.143892\n-0.175082\n0.06916\n-0.240234\n-0.243179\n0.132553\n-0.10939\n-0.006807\n-0.081922\n-0.033631\n\n\n-0.128473\n-0.163732\n0.052351\n-3.2502\n0.237454\n0.327462\n2.975345\n1.074392\n-0.642075\n-0.309154\n-1.427569\n0.209862\n-0.207053\n-0.785397\n-1.690689\n0.57705\n1.286289\n-0.260824\n-0.066723\n-0.378312\n-0.107758\n0.58553\n0.723803\n-0.085321\n-0.899026\n-0.508275\n0.946614\n0.681252\n0.591428\n-0.058463\n-0.611216\n-0.249337\n0.151805\n-0.201767\n-0.364704\n-0.279569\n0.032865\n…\n-0.103084\n-0.092279\n0.061387\n-0.229078\n0.214459\n0.018508\n-0.164547\n0.170245\n-0.028671\n-0.024243\n0.116811\n0.03172\n0.010574\n0.014084\n0.15063\n-0.053592\n-0.297773\n-0.033743\n0.264092\n-0.030906\n-0.04306\n-0.126682\n-0.050824\n-0.011592\n0.082704\n-0.186133\n0.172641\n-0.056459\n0.190109\n0.06259\n0.093085\n-0.251115\n0.141207\n0.180379\n-0.006493\n-0.155394\n-0.013597\n\n\n\n\n\n\n\nFinally, we can convert this to pandas if we want to perform analyses with that tool. Keep in mind that this loads the entire dataframe into memory.\n\n\nCode\ndata_only.to_pandas()\n\n\n\n\n\n\n\n\n\n\nX_1\nX_2\nX_3\nX_4\nX_5\nX_6\nX_7\nX_8\nX_9\nX_10\n...\nX_250\nX_251\nX_252\nX_253\nX_254\nX_255\nX_256\nX_257\nX_258\nX_259\n\n\n\n\n0\n0.431689\n0.121776\n-0.288611\n1.199042\n-0.758412\n-0.466926\n-0.777705\n-0.081231\n-0.619822\n-1.271280\n...\n-0.103231\n0.166172\n0.268637\n-0.249552\n-0.125842\n-0.010658\n0.148293\n-0.002996\n0.018602\n0.120415\n\n\n1\n-0.286125\n-0.139647\n0.521229\n-0.130772\n-0.392223\n-0.478905\n-2.190718\n-0.910039\n-0.923397\n-0.899920\n...\n0.039593\n-0.251191\n-0.145978\n-0.061276\n0.260967\n0.136172\n0.220407\n-0.016074\n0.245930\n-0.051766\n\n\n2\n0.044537\n0.093762\n0.380710\n-0.078268\n-0.332677\n-0.492756\n-0.542440\n-0.751058\n0.283140\n0.772951\n...\n0.073441\n0.003454\n-0.065908\n0.003793\n0.017154\n0.122071\n0.031753\n-0.115469\n-0.183939\n-0.037042\n\n\n3\n0.045477\n0.020634\n0.312316\n1.316000\n-0.831466\n-1.536956\n0.495057\n-1.254510\n-0.417021\n0.099831\n...\n0.143892\n-0.175082\n0.069160\n-0.240234\n-0.243179\n0.132553\n-0.109390\n-0.006807\n-0.081922\n-0.033631\n\n\n4\n-0.128473\n-0.163732\n0.052351\n-3.250200\n0.237454\n0.327462\n2.975345\n1.074392\n-0.642075\n-0.309154\n...\n-0.056459\n0.190109\n0.062590\n0.093085\n-0.251115\n0.141207\n0.180379\n-0.006493\n-0.155394\n-0.013597\n\n\n\n\n5 rows × 259 columns",
    "crumbs": [
      "How-To Guides",
      "Access JUMP profiles"
    ]
  }
]